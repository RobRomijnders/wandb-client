import logging
from typing import Any, Dict, Optional
import os
import wandb
from wandb.apis.internal import Api
import wandb.docker as docker
from wandb.errors import DockerError, LaunchError
from wandb.sdk.launch.builder.abstract import AbstractBuilder

from .._project_spec import (
    create_metadata_file,
    EntryPoint,
    get_entry_point_command,
    LaunchProject,
)
from ..utils import sanitize_wandb_api_key
from .build import (
    _create_build_ctx,
    construct_local_image_uri,
    generate_dockerfile,
    validate_docker_installation,
)

_GENERATED_DOCKERFILE_NAME = "Dockerfile.wandb-autogenerated"
_logger = logging.getLogger(__name__)


class DockerBuilder(AbstractBuilder):
    type = "docker"

    def __init__(self, builder_config: Dict[str, Any]):
        super().__init__(builder_config)
        validate_docker_installation()

    def build_image(
        self,
        launch_project: LaunchProject,
        registry: Optional[str],
        entrypoint: Optional[EntryPoint],
        docker_args: Dict[str, Any],
        runner_type: str,
    ) -> str:
        if registry:
            image_uri = f"{registry}:{launch_project.run_id}"
        else:
            image_uri = construct_local_image_uri(launch_project)
        entry_cmd = get_entry_point_command(entrypoint, launch_project.override_args)[0]
        dockerfile_str = generate_dockerfile(launch_project, runner_type, "docker")
        create_metadata_file(
            launch_project,
            image_uri,
            sanitize_wandb_api_key(entry_cmd),
            docker_args,
            sanitize_wandb_api_key(dockerfile_str),
        )
        if runner_type == "sagemaker" and launch_project.project_dir is not None:
            # sagemaker automatically appends train after the entrypoint
            # by redirecting to running a train script we can avoid issues
            # with argparse, and hopefully if the user intends for the train
            # argument to be present it is captured in the original jobs
            # command arguments
            with open(os.path.join(launch_project.project_dir, "train"), "w") as fp:
                fp.write(entry_cmd)
        build_ctx_path = _create_build_ctx(launch_project, dockerfile_str)
        dockerfile = os.path.join(build_ctx_path, _GENERATED_DOCKERFILE_NAME)
        try:
            docker.build(tags=[image_uri], file=dockerfile, context_path=build_ctx_path)
        except DockerError as e:
            raise LaunchError("Error communicating with docker client: {}".format(e))

        try:
            os.remove(build_ctx_path)
        except Exception:
            _logger.info(
                "Temporary docker context file %s was not deleted.", build_ctx_path
            )

        if registry:
            reg, tag = image_uri.split(":")
            wandb.termlog(f"Pushing image {image_uri}")
            push_resp = docker.push(reg, tag)
            if push_resp is None:
                raise LaunchError("Failed to push image to repository")
            if f"The push refers to repository [{registry}]" not in push_resp:
                raise LaunchError(f"Unable to push image to ECR, response: {push_resp}")

        return image_uri
