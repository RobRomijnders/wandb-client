import logging
from typing import Any, Dict, Optional
import os
import wandb
from wandb.apis.internal import Api
import wandb.docker as docker
from wandb.errors import DockerError, LaunchError
from wandb.sdk.launch.builder.abstract import AbstractBuilder

from .._project_spec import (
    create_metadata_file,
    EntryPoint,
    get_entry_point_command,
    LaunchProject,
)
from ..utils import sanitize_wandb_api_key
from .build import (
    _create_docker_build_ctx,
    generate_dockerfile,
    validate_docker_installation,
)

_GENERATED_DOCKERFILE_NAME = "Dockerfile.wandb-autogenerated"
_logger = logging.getLogger(__name__)


class DockerBuilder(AbstractBuilder):
    def __init__(self, builder_config: Dict[str, Any]):
        super().__init__(builder_config)
        validate_docker_installation()

    def build_image(
        self,
        api: Api,
        launch_project: LaunchProject,
        registry: Optional[str],
        entrypoint: EntryPoint,
        docker_args: Dict[str, Any],
        runner_type: str,
    ):
        wandb.termlog("USING DOCKER BUILDER")
        if registry:
            image_uri = f"{registry}/{launch_project.name}"
        else:
            image_uri = "launch-{}".format(launch_project.target_project)
        entry_cmd = get_entry_point_command(entrypoint, launch_project.override_args)[0]
        dockerfile_str = generate_dockerfile(launch_project, runner_type, "docker")
        create_metadata_file(
            launch_project,
            image_uri,
            sanitize_wandb_api_key(entry_cmd),
            docker_args,
            sanitize_wandb_api_key(dockerfile_str),
        )
        if runner_type == "sagemaker" and launch_project.project_dir is not None:
            # sagemaker automatically appends train after the entrypoint
            # by redirecting to running a train script we can avoid issues
            # with argparse, and hopefully if the user intends for the train
            # argument to be present it is captured in the original jobs
            # command arguments
            with open(os.path.join(launch_project.project_dir, "train"), "w") as fp:
                fp.write(entry_cmd)
        build_ctx_path = _create_docker_build_ctx(launch_project, dockerfile_str)
        dockerfile = os.path.join(build_ctx_path, _GENERATED_DOCKERFILE_NAME)
        try:
            docker.build(tags=[image_uri], file=dockerfile, context_path=build_ctx_path)
        except DockerError as e:
            raise LaunchError("Error communicating with docker client: {}".format(e))

        try:
            os.remove(build_ctx_path)
        except Exception:
            _logger.info(
                "Temporary docker context file %s was not deleted.", build_ctx_path
            )
        return image_uri
